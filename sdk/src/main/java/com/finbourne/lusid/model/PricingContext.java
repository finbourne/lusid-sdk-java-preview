/*
 * LUSID API
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | ----- | ----- | ---- | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3438
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.ModelSelection;
import com.finbourne.lusid.model.PricingOptions;
import com.finbourne.lusid.model.ResultDataKeyRule;
import com.finbourne.lusid.model.VendorModelRule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Pricing context node. In order to price an instrument a number of configuration parameters are required to determine which  (a) pricing model (ranging from a simple lookup of a market quote/price through to a Monte-Carlo simulation for the behaviour of its cashflows)  (b) vendor library (Lusid internal models or those provided through an external Vendor such as Refinitiv (proprietary) or QuantLib (open source)  are used in the pricing.    In conjunction with these there are a number of parameters that govern the behaviour of these models. For example, in pricing an Fx volatility  dependent product such as an Fx option, there are various parameters that affect model behaviour for the smile. In Lusid a distinction is made between  those which are understood natively and those which are only held for use with a given vendor-model combination. The problem is that, unlike market  quote data, there are few standards around model descriptions. Hence, apparently similar terminology can be mis-leading; for example in SABR models where  the basic parameters are agreed upon but most practical models have used an approximation with adjustments where the parameters can have wildly different meanings.  To avoid confusion or mis-behaviour in this area, where parameters are not understood to be interchangeable, they are only settable on a per-library per-model  basis, essentially as opaque data that will be given to the Vendor library \&quot;verbatim\&quot; but not used with any other.
 */
@ApiModel(description = "Pricing context node. In order to price an instrument a number of configuration parameters are required to determine which  (a) pricing model (ranging from a simple lookup of a market quote/price through to a Monte-Carlo simulation for the behaviour of its cashflows)  (b) vendor library (Lusid internal models or those provided through an external Vendor such as Refinitiv (proprietary) or QuantLib (open source)  are used in the pricing.    In conjunction with these there are a number of parameters that govern the behaviour of these models. For example, in pricing an Fx volatility  dependent product such as an Fx option, there are various parameters that affect model behaviour for the smile. In Lusid a distinction is made between  those which are understood natively and those which are only held for use with a given vendor-model combination. The problem is that, unlike market  quote data, there are few standards around model descriptions. Hence, apparently similar terminology can be mis-leading; for example in SABR models where  the basic parameters are agreed upon but most practical models have used an approximation with adjustments where the parameters can have wildly different meanings.  To avoid confusion or mis-behaviour in this area, where parameters are not understood to be interchangeable, they are only settable on a per-library per-model  basis, essentially as opaque data that will be given to the Vendor library \"verbatim\" but not used with any other.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class PricingContext {
  public static final String SERIALIZED_NAME_MODEL_RULES = "modelRules";
  @SerializedName(SERIALIZED_NAME_MODEL_RULES)
  private List<VendorModelRule> modelRules = null;

  public static final String SERIALIZED_NAME_MODEL_CHOICE = "modelChoice";
  @SerializedName(SERIALIZED_NAME_MODEL_CHOICE)
  private Map<String, ModelSelection> modelChoice = null;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  private PricingOptions options;

  public static final String SERIALIZED_NAME_RESULT_DATA_RULES = "resultDataRules";
  @SerializedName(SERIALIZED_NAME_RESULT_DATA_RULES)
  private List<ResultDataKeyRule> resultDataRules = null;


  public PricingContext modelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules; 
    return this;
  }

  public PricingContext addModelRulesItem(VendorModelRule modelRulesItem) {
   
    if (this.modelRules == null) {
      this.modelRules = new ArrayList<>();
    }
    this.modelRules.add(modelRulesItem);
    return this;
  }

   /**
   * The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.
   * @return modelRules
  **/
  @ApiModelProperty(value = "The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.")
  public List<VendorModelRule> getModelRules() {
    return modelRules;
  }

  public void setModelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules;
  }


  public PricingContext modelChoice(Map<String, ModelSelection> modelChoice) {
    this.modelChoice = modelChoice; 
    return this;
  }

  public PricingContext putModelChoiceItem(String key, ModelSelection modelChoiceItem) {
    if (this.modelChoice == null) {
      this.modelChoice = new HashMap<>();
    }
    this.modelChoice.put(key, modelChoiceItem);
    return this;
  }

   /**
   * The choice of which model selection (vendor library, pricing model) to use in evaluation of a given instrument type.
   * @return modelChoice
  **/
  @ApiModelProperty(value = "The choice of which model selection (vendor library, pricing model) to use in evaluation of a given instrument type.")
  public Map<String, ModelSelection> getModelChoice() {
    return modelChoice;
  }

  public void setModelChoice(Map<String, ModelSelection> modelChoice) {
    this.modelChoice = modelChoice;
  }


  public PricingContext options(PricingOptions options) {
    this.options = options; 
    return this;
  }

   /**
   * Get options
   * @return options
  **/
  @ApiModelProperty(value = "")
  public PricingOptions getOptions() {
    return options;
  }

  public void setOptions(PricingOptions options) {
    this.options = options;
  }


  public PricingContext resultDataRules(List<ResultDataKeyRule> resultDataRules) {
    this.resultDataRules = resultDataRules; 
    return this;
  }

  public PricingContext addResultDataRulesItem(ResultDataKeyRule resultDataRulesItem) {
   
    if (this.resultDataRules == null) {
      this.resultDataRules = new ArrayList<>();
    }
    this.resultDataRules.add(resultDataRulesItem);
    return this;
  }

   /**
   * Set of rules that control querying of unit results either for direct queries into aggregation or for  overriding intermediate calculations. For example, a dirty price is made up from a clean price and the accrued interest.  One might consider overriding the accrued interest calculated by a model (perhaps one wants to match an external value or simply disagrees with the  calculated result) and use that in calculation of the dirty price.
   * @return resultDataRules
  **/
  @ApiModelProperty(value = "Set of rules that control querying of unit results either for direct queries into aggregation or for  overriding intermediate calculations. For example, a dirty price is made up from a clean price and the accrued interest.  One might consider overriding the accrued interest calculated by a model (perhaps one wants to match an external value or simply disagrees with the  calculated result) and use that in calculation of the dirty price.")
  public List<ResultDataKeyRule> getResultDataRules() {
    return resultDataRules;
  }

  public void setResultDataRules(List<ResultDataKeyRule> resultDataRules) {
    this.resultDataRules = resultDataRules;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    return true;
  }

  @Override
  public int hashCode() {
    return super.hashCode();  
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PricingContext {\n");
    sb.append("    modelRules: ").append(toIndentedString(modelRules)).append("\n");
    sb.append("    modelChoice: ").append(toIndentedString(modelChoice)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    resultDataRules: ").append(toIndentedString(resultDataRules)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
