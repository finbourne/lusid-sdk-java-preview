/*
 * LUSID API
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | ----- | ----- | ---- | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3439
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.model;

import java.util.Objects;
import java.util.Arrays;
import com.finbourne.lusid.model.AggregationOptions;
import com.finbourne.lusid.model.ConfigurationRecipe;
import com.finbourne.lusid.model.MarketDataKeyRule;
import com.finbourne.lusid.model.MarketOptions;
import com.finbourne.lusid.model.PricingOptions;
import com.finbourne.lusid.model.VendorModelRule;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of &#39;parent&#39; recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.
 */
@ApiModel(description = "If it is desired to have multiple recipes, there is a strong likelihood that they will share various components.  A configuration recipe snippet allows a user to define a set of rules that can then be included into a parent recipe.  This allows sharing of common blocks of the recipe.                For example, a user might define a set of rules for resolving Fx and then include them into every recipe used firm-wide, thereby  enforcing consistency. As the rules can be permissioned differently using Shrine, it is possible to enable users to   read but not alter such a rule set.                The same applies to a set of pricing rules.                A configuration snippet must only contain one entry from the available set.                 Recipes are compiled from the set of snippets through a model that is analogous to inheritance.  A recipe can have a set of 'parent' recipes from which it inherits. These are specified in the inheritance section of a recipe.  Upon loading, the recipe will fall back on these recipe components for any options or rules that are not explicitly specified in the  named recipe for the request.                This allows control of pricing to be harmonised across a set of desks within an institution. Suppose that, e.g.  there are four desks looking after products under the areas of Fx, Rates, Credit and Exotics.  The model and market data for pricing given asset types would potentially be controlled by the appropriate desk; e.g. rules for Fx market data resolution being  controlled by the Fx desk. The exotics desk would likely depend upon rules for all the other asset classes as well as, say, correlation rules of its own.  It could inherit the market data and model rules from the other desks for finding the appropriate institution-standard data and then overlay that with the correlation rules.                Note that permissioning of the store means that one could decide that only a particular desk or control function could update certain rules. That would assist the abilitiy  to ensure that pricing is performed consistently and provide an audit of changes made to it along with restricting changes to appropriate authorised functions.")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ConfigurationRecipeSnippet {
  public static final String SERIALIZED_NAME_SCOPE = "scope";
  @SerializedName(SERIALIZED_NAME_SCOPE)
  private String scope;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_AGGREGATION_OPTIONS = "aggregationOptions";
  @SerializedName(SERIALIZED_NAME_AGGREGATION_OPTIONS)
  private AggregationOptions aggregationOptions;

  public static final String SERIALIZED_NAME_MODEL_RULES = "modelRules";
  @SerializedName(SERIALIZED_NAME_MODEL_RULES)
  private List<VendorModelRule> modelRules = null;

  public static final String SERIALIZED_NAME_PRICING_OPTIONS = "pricingOptions";
  @SerializedName(SERIALIZED_NAME_PRICING_OPTIONS)
  private PricingOptions pricingOptions;

  public static final String SERIALIZED_NAME_MARKET_RULES = "marketRules";
  @SerializedName(SERIALIZED_NAME_MARKET_RULES)
  private List<MarketDataKeyRule> marketRules = null;

  public static final String SERIALIZED_NAME_MARKET_OPTIONS = "marketOptions";
  @SerializedName(SERIALIZED_NAME_MARKET_OPTIONS)
  private MarketOptions marketOptions;

  public static final String SERIALIZED_NAME_RECIPE = "recipe";
  @SerializedName(SERIALIZED_NAME_RECIPE)
  private ConfigurationRecipe recipe;


  public ConfigurationRecipeSnippet scope(String scope) {
    this.scope = scope; 
    return this;
  }

   /**
   * The scope used when updating or inserting the Configuration Recipe snippet
   * @return scope
  **/
  @ApiModelProperty(required = true, value = "The scope used when updating or inserting the Configuration Recipe snippet")
  public String getScope() {
    return scope;
  }

  public void setScope(String scope) {
    this.scope = scope;
  }


  public ConfigurationRecipeSnippet code(String code) {
    this.code = code; 
    return this;
  }

   /**
   * User given string name (code) to identify the recipe.
   * @return code
  **/
  @ApiModelProperty(required = true, value = "User given string name (code) to identify the recipe.")
  public String getCode() {
    return code;
  }

  public void setCode(String code) {
    this.code = code;
  }


  public ConfigurationRecipeSnippet aggregationOptions(AggregationOptions aggregationOptions) {
    this.aggregationOptions = aggregationOptions; 
    return this;
  }

   /**
   * Get aggregationOptions
   * @return aggregationOptions
  **/
  @ApiModelProperty(value = "")
  public AggregationOptions getAggregationOptions() {
    return aggregationOptions;
  }

  public void setAggregationOptions(AggregationOptions aggregationOptions) {
    this.aggregationOptions = aggregationOptions;
  }


  public ConfigurationRecipeSnippet modelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules; 
    return this;
  }

  public ConfigurationRecipeSnippet addModelRulesItem(VendorModelRule modelRulesItem) {
   
    if (this.modelRules == null) {
      this.modelRules = new ArrayList<>();
    }
    this.modelRules.add(modelRulesItem);
    return this;
  }

   /**
   * The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.
   * @return modelRules
  **/
  @ApiModelProperty(value = "The set of model rules that are available. There may be multiple rules for Vendors, but only one per model-instrument pair.  Which of these preference sets is used depends upon the model choice selection if specified, or failing that the global default model specification  in the options.")
  public List<VendorModelRule> getModelRules() {
    return modelRules;
  }

  public void setModelRules(List<VendorModelRule> modelRules) {
    this.modelRules = modelRules;
  }


  public ConfigurationRecipeSnippet pricingOptions(PricingOptions pricingOptions) {
    this.pricingOptions = pricingOptions; 
    return this;
  }

   /**
   * Get pricingOptions
   * @return pricingOptions
  **/
  @ApiModelProperty(value = "")
  public PricingOptions getPricingOptions() {
    return pricingOptions;
  }

  public void setPricingOptions(PricingOptions pricingOptions) {
    this.pricingOptions = pricingOptions;
  }


  public ConfigurationRecipeSnippet marketRules(List<MarketDataKeyRule> marketRules) {
    this.marketRules = marketRules; 
    return this;
  }

  public ConfigurationRecipeSnippet addMarketRulesItem(MarketDataKeyRule marketRulesItem) {
   
    if (this.marketRules == null) {
      this.marketRules = new ArrayList<>();
    }
    this.marketRules.add(marketRulesItem);
    return this;
  }

   /**
   * The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.
   * @return marketRules
  **/
  @ApiModelProperty(value = "The set of rules that define how to resolve particular use cases. These can be relatively general or specific in nature.  Nominally any number are possible and will be processed in order where applicable. However, there is evidently a potential  for increased computational cost where many rules must be applied to resolve data. Ensuring that portfolios are structured in  such a way as to reduce the number of rules required is therefore sensible.")
  public List<MarketDataKeyRule> getMarketRules() {
    return marketRules;
  }

  public void setMarketRules(List<MarketDataKeyRule> marketRules) {
    this.marketRules = marketRules;
  }


  public ConfigurationRecipeSnippet marketOptions(MarketOptions marketOptions) {
    this.marketOptions = marketOptions; 
    return this;
  }

   /**
   * Get marketOptions
   * @return marketOptions
  **/
  @ApiModelProperty(value = "")
  public MarketOptions getMarketOptions() {
    return marketOptions;
  }

  public void setMarketOptions(MarketOptions marketOptions) {
    this.marketOptions = marketOptions;
  }


  public ConfigurationRecipeSnippet recipe(ConfigurationRecipe recipe) {
    this.recipe = recipe; 
    return this;
  }

   /**
   * Get recipe
   * @return recipe
  **/
  @ApiModelProperty(value = "")
  public ConfigurationRecipe getRecipe() {
    return recipe;
  }

  public void setRecipe(ConfigurationRecipe recipe) {
    this.recipe = recipe;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    return true;
  }

  @Override
  public int hashCode() {
    return super.hashCode();  
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigurationRecipeSnippet {\n");
    sb.append("    scope: ").append(toIndentedString(scope)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    aggregationOptions: ").append(toIndentedString(aggregationOptions)).append("\n");
    sb.append("    modelRules: ").append(toIndentedString(modelRules)).append("\n");
    sb.append("    pricingOptions: ").append(toIndentedString(pricingOptions)).append("\n");
    sb.append("    marketRules: ").append(toIndentedString(marketRules)).append("\n");
    sb.append("    marketOptions: ").append(toIndentedString(marketOptions)).append("\n");
    sb.append("    recipe: ").append(toIndentedString(recipe)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
