/*
 * LUSID API
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | ----- | ----- | ---- | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3439
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.api;

import com.finbourne.lusid.ApiException;
import com.finbourne.lusid.model.AdjustHolding;
import com.finbourne.lusid.model.AdjustHoldingRequest;
import com.finbourne.lusid.model.BucketedCashFlowRequest;
import com.finbourne.lusid.model.BucketedCashFlowResponse;
import com.finbourne.lusid.model.CreatePortfolioDetails;
import com.finbourne.lusid.model.CreateTransactionPortfolioRequest;
import com.finbourne.lusid.model.DeletedEntityResponse;
import com.finbourne.lusid.model.HoldingsAdjustment;
import com.finbourne.lusid.model.LusidProblemDetails;
import com.finbourne.lusid.model.LusidValidationProblemDetails;
import java.time.OffsetDateTime;
import com.finbourne.lusid.model.PerpetualProperty;
import com.finbourne.lusid.model.Portfolio;
import com.finbourne.lusid.model.PortfolioDetails;
import com.finbourne.lusid.model.ResourceListOfA2BDataRecord;
import com.finbourne.lusid.model.ResourceListOfA2BMovementRecord;
import com.finbourne.lusid.model.ResourceListOfHoldingsAdjustmentHeader;
import com.finbourne.lusid.model.ResourceListOfInstrumentCashFlow;
import com.finbourne.lusid.model.ResourceListOfPortfolioCashFlow;
import com.finbourne.lusid.model.ResourceListOfPortfolioCashLadder;
import com.finbourne.lusid.model.ResourceListOfTransaction;
import com.finbourne.lusid.model.TransactionQueryParameters;
import com.finbourne.lusid.model.TransactionRequest;
import com.finbourne.lusid.model.UpsertPortfolioTransactionsResponse;
import com.finbourne.lusid.model.UpsertTransactionPropertiesResponse;
import com.finbourne.lusid.model.VersionedResourceListOfOutputTransaction;
import com.finbourne.lusid.model.VersionedResourceListOfPortfolioHolding;
import com.finbourne.lusid.model.VersionedResourceListOfTransaction;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for TransactionPortfoliosApi
 */
@Ignore
public class TransactionPortfoliosApiTest {

    private final TransactionPortfoliosApi api = new TransactionPortfoliosApi();

    
    /**
     * Adjust holdings
     *
     * Adjust one or more holdings of the specified transaction portfolio to the provided targets. LUSID will  automatically construct adjustment transactions to ensure that the holdings which have been adjusted are  always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void adjustHoldingsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        List<AdjustHoldingRequest> adjustHoldingRequest = null;
        List<String> reconciliationMethods = null;
        AdjustHolding response = api.adjustHoldings(scope, code, effectiveAt, adjustHoldingRequest, reconciliationMethods);

        // TODO: test validations
    }
    
    /**
     * Build transactions
     *
     * Builds and returns all transactions that affect the holdings of a portfolio over a given interval of  effective time into a set of output transactions. This includes transactions automatically generated by  LUSID such as holding adjustments.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void buildTransactionsTest() throws ApiException {
        String scope = null;
        String code = null;
        TransactionQueryParameters transactionQueryParameters = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> propertyKeys = null;
        Integer limit = null;
        String page = null;
        VersionedResourceListOfOutputTransaction response = api.buildTransactions(scope, code, transactionQueryParameters, asAt, filter, propertyKeys, limit, page);

        // TODO: test validations
    }
    
    /**
     * Cancel adjust holdings
     *
     * Cancel all previous holding adjustments made on the specified transaction portfolio for a specified effective  datetime. This should be used to undo holding adjustments made via set holdings or adjust holdings.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelAdjustHoldingsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        DeletedEntityResponse response = api.cancelAdjustHoldings(scope, code, effectiveAt);

        // TODO: test validations
    }
    
    /**
     * Cancel transactions
     *
     * Cancel one or more transactions from the transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void cancelTransactionsTest() throws ApiException {
        String scope = null;
        String code = null;
        List<String> transactionIds = null;
        DeletedEntityResponse response = api.cancelTransactions(scope, code, transactionIds);

        // TODO: test validations
    }
    
    /**
     * Create portfolio
     *
     * Create a transaction portfolio in a particular scope.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void createPortfolioTest() throws ApiException {
        String scope = null;
        CreateTransactionPortfolioRequest createTransactionPortfolioRequest = null;
        Portfolio response = api.createPortfolio(scope, createTransactionPortfolioRequest);

        // TODO: test validations
    }
    
    /**
     * Delete properties from transaction
     *
     * Delete one or more properties from a single transaction in a transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deletePropertiesFromTransactionTest() throws ApiException {
        String scope = null;
        String code = null;
        String transactionId = null;
        List<String> propertyKeys = null;
        DeletedEntityResponse response = api.deletePropertiesFromTransaction(scope, code, transactionId, propertyKeys);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get A2B data
     *
     * Get an A2B report for the given portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getA2BDataTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromEffectiveAt = null;
        String toEffectiveAt = null;
        OffsetDateTime asAt = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        List<String> propertyKeys = null;
        String filter = null;
        ResourceListOfA2BDataRecord response = api.getA2BData(scope, code, fromEffectiveAt, toEffectiveAt, asAt, recipeIdScope, recipeIdCode, propertyKeys, filter);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get an A2B report at the movement level for the given portfolio.
     *
     * Get an A2B report at the movement level for the given portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getA2BMovementsTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromEffectiveAt = null;
        String toEffectiveAt = null;
        OffsetDateTime asAt = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        List<String> propertyKeys = null;
        String filter = null;
        ResourceListOfA2BMovementRecord response = api.getA2BMovements(scope, code, fromEffectiveAt, toEffectiveAt, asAt, recipeIdScope, recipeIdCode, propertyKeys, filter);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get bucketed cash flows from a list of portfolios
     *
     * We bucket/aggregate a transaction portfolio&#39;s instruments by date or tenor specified in the request.  The cashflows are grouped by both instrumentId and currency.                 If you want transactional level cashflow, please use the &#39;GetUpsertableCashFlows&#39; endpoint.  If you want instrument cashflow, please use the &#39;GetPortfolioCashFlows&#39; endpoint.  Note that these endpoints do not apply bucketing.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getBucketedCashFlowsTest() throws ApiException {
        String scope = null;
        String code = null;
        BucketedCashFlowRequest bucketedCashFlowRequest = null;
        BucketedCashFlowResponse response = api.getBucketedCashFlows(scope, code, bucketedCashFlowRequest);

        // TODO: test validations
    }
    
    /**
     * Get details
     *
     * Get certain details associated with a transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getDetailsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        PortfolioDetails response = api.getDetails(scope, code, effectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * Get holdings
     *
     * Calculate holdings for a transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getHoldingsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> propertyKeys = null;
        Boolean byTaxlots = null;
        VersionedResourceListOfPortfolioHolding response = api.getHoldings(scope, code, effectiveAt, asAt, filter, propertyKeys, byTaxlots);

        // TODO: test validations
    }
    
    /**
     * Get holdings adjustment
     *
     * Get a holdings adjustment made to a transaction portfolio at a specific effective datetime. Note that a  holdings adjustment will only be returned if one exists for the specified effective datetime.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getHoldingsAdjustmentTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        HoldingsAdjustment response = api.getHoldingsAdjustment(scope, code, effectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get holdings with orders
     *
     * Get the holdings of a transaction portfolio. Create virtual holdings for any outstanding orders,  and account for order state/fulfillment; that is, treat outstanding orders (and related records) as  if they had been realised at moment of query.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getHoldingsWithOrdersTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> propertyKeys = null;
        Boolean byTaxlots = null;
        VersionedResourceListOfPortfolioHolding response = api.getHoldingsWithOrders(scope, code, effectiveAt, asAt, filter, propertyKeys, byTaxlots);

        // TODO: test validations
    }
    
    /**
     * [BETA] Get portfolio cash flows
     *
     * Get the set of cash flows that occur in a window for the transaction portfolio&#39;s instruments.                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPortfolioCashFlowsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        String windowStart = null;
        String windowEnd = null;
        OffsetDateTime asAt = null;
        String filter = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        ResourceListOfInstrumentCashFlow response = api.getPortfolioCashFlows(scope, code, effectiveAt, windowStart, windowEnd, asAt, filter, recipeIdScope, recipeIdCode);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get portfolio cash ladder
     *
     * Get a cash ladder for a transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPortfolioCashLadderTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromEffectiveAt = null;
        String toEffectiveAt = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        ResourceListOfPortfolioCashLadder response = api.getPortfolioCashLadder(scope, code, fromEffectiveAt, toEffectiveAt, effectiveAt, asAt, filter, recipeIdScope, recipeIdCode);

        // TODO: test validations
    }
    
    /**
     * [EARLY ACCESS] Get portfolio cash statement
     *
     * Get a cash statement for a transaction portfolio.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPortfolioCashStatementTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromEffectiveAt = null;
        String toEffectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        ResourceListOfPortfolioCashFlow response = api.getPortfolioCashStatement(scope, code, fromEffectiveAt, toEffectiveAt, asAt, filter, recipeIdScope, recipeIdCode);

        // TODO: test validations
    }
    
    /**
     * Get transactions
     *
     * Retrieve all the transactions that occurred during a particular time interval.     If the portfolio is a derived transaction portfolio, the transactions returned are the  union set of all transactions of the parent (and any grandparents, etc.) as well as  those of the derived transaction portfolio itself.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getTransactionsTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromTransactionDate = null;
        String toTransactionDate = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> propertyKeys = null;
        String page = null;
        Integer limit = null;
        VersionedResourceListOfTransaction response = api.getTransactions(scope, code, fromTransactionDate, toTransactionDate, asAt, filter, propertyKeys, page, limit);

        // TODO: test validations
    }
    
    /**
     * [BETA] Get upsertable portfolio cash flows.
     *
     * Get the set of cash flows that occur in a window for the given portfolio instruments as a set of upsertable transactions (DTOs).                Note that grouping can affect the quantity of information returned; where a holding is an amalgamation of one or more (e.g. cash) instruments, a unique  transaction identifier will not be available. The same may go for diagnostic information (e.g. multiple sources of an aggregate cash amount on a date that is  not split out. Grouping at the transaction and instrument level is recommended for those seeking to attribute individual flows.                In essence this is identical to the &#39;GetCashFlows&#39; endpoint but returns the cash flows as a set of transactions suitable for directly putting back into LUSID.  There are a couple of important points:  (1) Internally it can not be fully known where the user wishes to insert these transactions, e.g. portfolio and movement type.      These are therefore defaulted to a sensible option; the user will likely need to change these.  (2) Similarly, knowledge of any properties the user might wish to add to a transaction are unknown and consequently left empty.  (3) The transaction id that is added is simply a concatenation of the original transaction id, instrument id and payment date and direction. The user can happily override this.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getUpsertablePortfolioCashFlowsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        String windowStart = null;
        String windowEnd = null;
        OffsetDateTime asAt = null;
        String filter = null;
        String recipeIdScope = null;
        String recipeIdCode = null;
        ResourceListOfTransaction response = api.getUpsertablePortfolioCashFlows(scope, code, effectiveAt, windowStart, windowEnd, asAt, filter, recipeIdScope, recipeIdCode);

        // TODO: test validations
    }
    
    /**
     * List holdings adjustments
     *
     * List the holdings adjustments made to the specified transaction portfolio over a specified interval of effective time.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listHoldingsAdjustmentsTest() throws ApiException {
        String scope = null;
        String code = null;
        String fromEffectiveAt = null;
        String toEffectiveAt = null;
        OffsetDateTime asAt = null;
        ResourceListOfHoldingsAdjustmentHeader response = api.listHoldingsAdjustments(scope, code, fromEffectiveAt, toEffectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * [EARLY ACCESS] Resolve instrument
     *
     * Try to resolve the instrument for transaction and holdings for a given instrument identifier and a specified    period of time. Also update the instrument identifiers with the given instrument identifiers collection.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void resolveInstrumentTest() throws ApiException {
        String scope = null;
        String code = null;
        String instrumentIdentifierType = null;
        String instrumentIdentifierValue = null;
        String fromEffectiveAt = null;
        Map<String, String> requestBody = null;
        UpsertPortfolioTransactionsResponse response = api.resolveInstrument(scope, code, instrumentIdentifierType, instrumentIdentifierValue, fromEffectiveAt, requestBody);

        // TODO: test validations
    }
    
    /**
     * Set holdings
     *
     * Set the holdings of the specified transaction portfolio to the provided targets. LUSID will automatically  construct adjustment transactions to ensure that the entire set of holdings for the transaction portfolio  are always set to the provided targets for the specified effective datetime. Read more about the difference between  adjusting and setting holdings here https://support.lusid.com/how-do-i-adjust-my-holdings.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void setHoldingsTest() throws ApiException {
        String scope = null;
        String code = null;
        String effectiveAt = null;
        List<AdjustHoldingRequest> adjustHoldingRequest = null;
        List<String> reconciliationMethods = null;
        AdjustHolding response = api.setHoldings(scope, code, effectiveAt, adjustHoldingRequest, reconciliationMethods);

        // TODO: test validations
    }
    
    /**
     * Upsert portfolio details
     *
     * Create or update certain details for a particular transaction portfolio. The details are updated if they already exist, and inserted if they do not.                Note that not all elements of a transaction portfolio definition are  modifiable once it has been created due to the potential implications for data already stored.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void upsertPortfolioDetailsTest() throws ApiException {
        String scope = null;
        String code = null;
        CreatePortfolioDetails createPortfolioDetails = null;
        String effectiveAt = null;
        PortfolioDetails response = api.upsertPortfolioDetails(scope, code, createPortfolioDetails, effectiveAt);

        // TODO: test validations
    }
    
    /**
     * Upsert transaction properties
     *
     * Create or update one or more transaction properties for a single transaction in the transaction portfolio.  Each property will be updated if it already exists and created if it does not.  Both transaction and portfolio must exist at the time when properties are created or updated.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void upsertTransactionPropertiesTest() throws ApiException {
        String scope = null;
        String code = null;
        String transactionId = null;
        Map<String, PerpetualProperty> requestBody = null;
        UpsertTransactionPropertiesResponse response = api.upsertTransactionProperties(scope, code, transactionId, requestBody);

        // TODO: test validations
    }
    
    /**
     * Upsert transactions
     *
     * Create or update transactions in the transaction portfolio. A transaction will be updated  if it already exists and created if it does not.  The maximum number of transactions that this method can upsert per request is 10,000.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void upsertTransactionsTest() throws ApiException {
        String scope = null;
        String code = null;
        List<TransactionRequest> transactionRequest = null;
        UpsertPortfolioTransactionsResponse response = api.upsertTransactions(scope, code, transactionRequest);

        // TODO: test validations
    }
    
}
