/*
 * LUSID API
 * # Introduction  This page documents the [LUSID APIs](https://www.lusid.com/api/swagger), which allows authorised clients to query and update their data within the LUSID platform.  SDKs to interact with the LUSID APIs are available in the following languages and frameworks:  * [C#](https://github.com/finbourne/lusid-sdk-csharp) * [Java](https://github.com/finbourne/lusid-sdk-java) * [JavaScript](https://github.com/finbourne/lusid-sdk-js) * [Python](https://github.com/finbourne/lusid-sdk-python) * [Angular](https://github.com/finbourne/lusid-sdk-angular)  The LUSID platform is made up of a number of sub-applications. You can find the API / swagger documentation by following the links in the table below.   | Application | Description | API / Swagger Documentation | | ----- | ----- | ---- | | LUSID | Open, API-first, developer-friendly investment data platform. | [Swagger](https://www.lusid.com/api/swagger/index.html) | | Web app | User-facing front end for LUSID. | [Swagger](https://www.lusid.com/app/swagger/index.html) | | Scheduler | Automated job scheduler. | [Swagger](https://www.lusid.com/scheduler2/swagger/index.html) | | Insights |Monitoring and troubleshooting service. | [Swagger](https://www.lusid.com/insights/swagger/index.html) | | Identity | Identity management for LUSID (in conjuction with Access) | [Swagger](https://www.lusid.com/identity/swagger/index.html) | | Access | Access control for LUSID (in conjunction with Identity) | [Swagger](https://www.lusid.com/access/swagger/index.html) | | Drive | Secure file repository and manager for collaboration. | [Swagger](https://www.lusid.com/drive/swagger/index.html) | | Luminesce | Data virtualisation service (query data from multiple providers, including LUSID) | [Swagger](https://www.lusid.com/honeycomb/swagger/index.html) | | Notification | Notification service. | [Swagger](https://www.lusid.com/notifications/swagger/index.html) | | Configuration | File store for secrets and other sensitive information. | [Swagger](https://www.lusid.com/configuration/swagger/index.html) | 
 *
 * The version of the OpenAPI document: 0.11.3439
 * Contact: info@finbourne.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.finbourne.lusid.api;

import com.finbourne.lusid.ApiException;
import com.finbourne.lusid.model.AccessMetadataValue;
import com.finbourne.lusid.model.DeletedEntityResponse;
import com.finbourne.lusid.model.LusidProblemDetails;
import com.finbourne.lusid.model.LusidValidationProblemDetails;
import java.time.OffsetDateTime;
import com.finbourne.lusid.model.PagedResourceListOfPerson;
import com.finbourne.lusid.model.Person;
import com.finbourne.lusid.model.ResourceListOfAccessMetadataValueOf;
import com.finbourne.lusid.model.ResourceListOfPropertyInterval;
import com.finbourne.lusid.model.ResourceListOfRelation;
import com.finbourne.lusid.model.ResourceListOfRelationship;
import com.finbourne.lusid.model.SetPersonIdentifiersRequest;
import com.finbourne.lusid.model.SetPersonPropertiesRequest;
import com.finbourne.lusid.model.UpsertPersonAccessMetadataRequest;
import com.finbourne.lusid.model.UpsertPersonRequest;
import org.junit.Test;
import org.junit.Ignore;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for PersonsApi
 */
@Ignore
public class PersonsApiTest {

    private final PersonsApi api = new PersonsApi();

    
    /**
     * [EXPERIMENTAL] Delete person
     *
     * Delete a person. Deletion will be valid from the person&#39;s creation datetime.  This means that the person will no longer exist at any effective datetime from the asAt datetime of deletion.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deletePersonTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        DeletedEntityResponse response = api.deletePerson(idTypeScope, idTypeCode, code);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Delete a Person Access Metadata entry
     *
     * Deletes the Person Access Metadata entry that exactly matches the provided identifier parts.    It is important to always check to verify success (or failure).
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deletePersonAccessMetadataTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String metadataKey = null;
        String effectiveAt = null;
        DeletedEntityResponse response = api.deletePersonAccessMetadata(idTypeScope, idTypeCode, code, metadataKey, effectiveAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Delete Person Identifiers
     *
     * Delete identifiers that belong to the given property keys of the person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deletePersonIdentifiersTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        List<String> propertyKeys = null;
        String effectiveAt = null;
        DeletedEntityResponse response = api.deletePersonIdentifiers(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Delete Person Properties
     *
     * Delete all properties that belong to the given property keys of the person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void deletePersonPropertiesTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        List<String> propertyKeys = null;
        String effectiveAt = null;
        DeletedEntityResponse response = api.deletePersonProperties(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get Access Metadata rules for a Person
     *
     * Pass the Scope and Code of the Person identifier along with the person code parameter to retrieve the associated Access Metadata
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getAllPersonAccessMetadataTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        Map<String, List<AccessMetadataValue>> response = api.getAllPersonAccessMetadata(idTypeScope, idTypeCode, code, effectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get Person
     *
     * Retrieve the definition of a person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPersonTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        List<String> propertyKeys = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        Person response = api.getPerson(idTypeScope, idTypeCode, code, propertyKeys, effectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get an entry identified by a metadataKey in the Access Metadata of a Person
     *
     * Get a specific Person Access Metadata by specifying the corresponding identifier parts and Person code                No matching will be performed through this endpoint. To retrieve an entry, it is necessary to specify, exactly, the identifier of the entry
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPersonAccessMetadataByKeyTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String metadataKey = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        List<AccessMetadataValue> response = api.getPersonAccessMetadataByKey(idTypeScope, idTypeCode, code, metadataKey, effectiveAt, asAt);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get Person Property Time Series
     *
     * List the complete time series of a person property.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPersonPropertyTimeSeriesTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String propertyKey = null;
        OffsetDateTime asAt = null;
        String filter = null;
        String page = null;
        Integer limit = null;
        ResourceListOfPropertyInterval response = api.getPersonPropertyTimeSeries(idTypeScope, idTypeCode, code, propertyKey, asAt, filter, page, limit);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get Relations for Person
     *
     * Get relations for the specified person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPersonRelationsTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> identifierTypes = null;
        ResourceListOfRelation response = api.getPersonRelations(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Get Relationships for Person
     *
     * Get relationships for the specified person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getPersonRelationshipsTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String filter = null;
        List<String> identifierTypes = null;
        ResourceListOfRelationship response = api.getPersonRelationships(idTypeScope, idTypeCode, code, effectiveAt, asAt, filter, identifierTypes);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] List Persons
     *
     * List persons which have identifiers of a specific identifier type&#39;s scope and code, and satisfies filter criteria.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void listPersonsTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String effectiveAt = null;
        OffsetDateTime asAt = null;
        String page = null;
        Integer start = null;
        Integer limit = null;
        String filter = null;
        List<String> propertyKeys = null;
        PagedResourceListOfPerson response = api.listPersons(idTypeScope, idTypeCode, effectiveAt, asAt, page, start, limit, filter, propertyKeys);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Set Person Identifiers
     *
     * Set identifiers of the person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void setPersonIdentifiersTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        SetPersonIdentifiersRequest setPersonIdentifiersRequest = null;
        Person response = api.setPersonIdentifiers(idTypeScope, idTypeCode, code, setPersonIdentifiersRequest);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Set Person Properties
     *
     * Set properties of the person.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void setPersonPropertiesTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        SetPersonPropertiesRequest setPersonPropertiesRequest = null;
        Person response = api.setPersonProperties(idTypeScope, idTypeCode, code, setPersonPropertiesRequest);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Upsert Person
     *
     * Create or update a new person under the specified scope.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void upsertPersonTest() throws ApiException {
        UpsertPersonRequest upsertPersonRequest = null;
        Person response = api.upsertPerson(upsertPersonRequest);

        // TODO: test validations
    }
    
    /**
     * [EXPERIMENTAL] Upsert a Person Access Metadata entry associated with a specific metadataKey. This creates or updates the data in LUSID.
     *
     * Update or insert one Person Access Metadata entry in a single scope. An item will be updated if it already exists  and inserted if it does not.                The response will return the successfully updated or inserted Person Access Metadata rule or failure message if unsuccessful.                It is important to always check to verify success (or failure).                Multiple rules for a metadataKey can exist with different effective at dates, when resources are accessed the rule that is active for the current time will be fetched.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void upsertPersonAccessMetadataTest() throws ApiException {
        String idTypeScope = null;
        String idTypeCode = null;
        String code = null;
        String metadataKey = null;
        UpsertPersonAccessMetadataRequest upsertPersonAccessMetadataRequest = null;
        String effectiveAt = null;
        ResourceListOfAccessMetadataValueOf response = api.upsertPersonAccessMetadata(idTypeScope, idTypeCode, code, metadataKey, upsertPersonAccessMetadataRequest, effectiveAt);

        // TODO: test validations
    }
    
}
